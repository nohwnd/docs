---
id: quick-start
title: Quick Start
sidebar_label: Quick Start
---

## What is Pester?

Pester is a testing and mocking framework for PowerShell.

Pester provides a framework for writing and running tests. Pester is most commonly 
used for writing unit and integration tests, but it is not limited to just that. 
It is also a base for tools that validate whole environments, computer deployments, database configurations and so on. 

Pester follows a file naming convention `*.Tests.ps1`, and uses a simple set of functions: 
`Describe`, `Context`, `It`, `Should` and `Mock` to create a mini-DSL for writing your tests.

Pester tests can execute any command or script that is accessible to a Pester test file. This
includes functions, Cmdlets, Modules and scripts. Pester can be run locally, where it integrates well 
with Visual Studio Code, and it can of course be integrated into a build script in a CI pipeline.

Pester contains a powerful set of Mocking capabilities that allow tests to replace the behavior of any 
command inside of a piece of PowerShell code being tested. See [Mocking with Pester](./usage/mocking).

Pester can produce artifacts such as Test Results file and can be used for generating
[Code Coverage](./usage/code-coverage) and [Test Result](./usage/test-results) files for reporting 
results in CI pipeline.

## Installing Pester

To install Pester it is usually enough to just do `Install-Module Pester -Force` followed by 
`Import-Module Pester -PassThru`. This is the output you should see in the console: 

```shell
C:\> Import-Module Pester -Passthru

ModuleType Version    PreRelease Name
---------- -------    ---------- ----
Script     5.0.4                 Pester
```

Full installation guide is available in [installation](introduction/installation).

## Creating a Pester Test

To start using Pester, create a new file called `Get-Planet.Tests.ps1`. `Get-Planet` is the name of the function
we will be testing. Feel free to replace that with your own function name. The file name is important because Pester 
uses a naming convention, all `*.Tests.ps1` files will be inspected for tests.

Inside of the file paste this code:

```powershell
BeforeAll { 
    function Get-Planet ([string]$Name = '*') {
        $planets = @(
            @{ Name = 'Mercury' }
            @{ Name = 'Venus'   }
            @{ Name = 'Earth'   }
            @{ Name = 'Mars'    }
            @{ Name = 'Jupiter' }
            @{ Name = 'Saturn'  }
            @{ Name = 'Uranus'  }
            @{ Name = 'Neptune' }
        ) | ForEach-Object { [PSCustomObject] $_ }

        $planets | Where-Object { $_.Name -like $Name }
    }
}

Describe 'Get-Planet' {
    It 'Given no parameters, it lists all 8 planets' {
        $allPlanets = Get-Planet
        $allPlanets.Count | Should -Be 8
    }
}
```

This code uses multiple Pester keywords, and we will go over them in detail soon, but for now let's just run it.

In your console run `Invoke-Pester -Output Detailed C:\t\Planets\Get-Planet.Tests.ps1`:

```shell
Starting discovery in 1 files.
Discovering in C:\t\Planets\Get-Planet.Tests.ps1.
Found 1 tests. 41ms
Discovery finished in 77ms.

Running tests from 'C:\t\Planets\Get-Planet.Tests.ps1'
Describing Get-Planet
  [+] Given no parameters, it lists all 8 planets 20ms (18ms|2ms)
Tests completed in 179ms
Tests Passed: 1, Failed: 0, Skipped: 0 NotRun: 0
```

Looking at the last line of output you can see that we run 1 test and it Passed. Good job, you just run your first Pester test! ðŸ¥³ðŸ¥³ðŸ¥³

### Understanding our test

In the previous run, our test passed, and if you'd run it again it would pass again. That is the beauty of automated testing. This is because using the `Should` keyword we are saying:

> ðŸ‘‰ "There should be 8 items in `$allPlanets`."

And there are. 

But how did we know that we want to test for exactly that? Well, we didn't. It was just one example of how we could describe our Solar System. You can try remembering some facts about it and try writing them as tests.

Here are few examples: 

- Earth is the third planet in our Solar System. 
- Pluto is not part of our Solar System.
- The planets go in this order: Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune.
  

```powershell
It 'Earth is the third planet in our Solar System' {
    $allPlanets = Get-Planet
    $allPlanets[2].Name | Should -Be 'Earth'
}
```

```powershell
It 'Pluto is not part of our Solar System' {
    $allPlanets = Get-Planet
    $plutos = $allPlanets | Where-Object Name -EQ 'Pluto'
    $plutos.Count | Should -Be 0
}
```

```powershell
It 'Planets have this order: Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune' {
    $allPlanets = Get-Planet
    $planetsInOrder = $allPlanets.Name -join ', ' 
    $planetsInOrder | Should -Be 'Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune'
} 
```

Try adding those tests into your `Get-Planet.Tests.ps1` file. Put them under the other `It` block, but make sure they are placed within the curly braces associated with `Describe`.

### Breaking our test, by breaking the tested function

In the previous run, our test passed, and if you run it again it will pass again. That is the beauty of automated testing. This is because using the `Should` keyword we are saying:

> ðŸ‘‰ There should be 8 items in `$allPlanets`.

And there are. 

To understand why the test passes, let's try to break it. 

There are few ways to break the test, one of them is adding Pluto back into our Solar System.

```powershell
$planets = @(
    @{ Name = 'Mercury' }
    @{ Name = 'Venus'   }
    @{ Name = 'Earth'   }
    @{ Name = 'Mars'    }
    @{ Name = 'Jupiter' }
    @{ Name = 'Saturn'  }
    @{ Name = 'Uranus'  }
    @{ Name = 'Neptune' }
    @{ Name = 'Pluto'   }
) | ForEach-Object { [PSCustomObject] $_ }
```

This will break the assertion that we have in our test, we no longer return 8 items from the tested function. Instead we now return 9. Running the test, it will no longer pass: 

```shell
Invoke-Pester -Output Detailed C:\t\Planets\Get-Planet.Tests.ps1


Starting discovery in 1 files.
Discovering in C:\t\Planets\Get-Planet.Tests.ps1.
Found 1 tests. 9ms
Discovery finished in 21ms.

Running tests from 'C:\t\Planets\Get-Planet.Tests.ps1'
Describing Get-Planet
  [-] Given no parameters, it lists all 8 planets 19ms (12ms|7ms)
   Expected 8, but got 9.
   at $allPlanets.Count | Should -Be 8, C:\t\Planets\Get-Planet.Tests.ps1:22
   at <ScriptBlock>, C:\t\Planets\Get-Planet.Tests.ps1:22
Tests completed in 183ms
Tests Passed: 0, Failed: 1, Skipped: 0 NotRun: 0
```

The error is: `Expected 8, but got 9.`, this exactly reflects the change that we made to the tested function, we added one more item to the collection of planets, and the test confirms that the function no longer does what we expect. 

### Breaking our test, by breaking the test expectation

The change that we just did is not the only change that we can make to break the test. There are other ways to do it. We can change the expected count to be 1, saying that there is just one planet orbiting the Sun, by changing the `Should` to `$allPlanets.Count | Should -Be 1`. This will also break the test: 

```shell
Describing Get-Planet
  [-] Given no parameters, it lists all 8 planets 25ms (21ms|4ms)
   Expected 1, but got 8.
   at $allPlanets.Count | Should -Be 1, C:\t\Planets\Get-Planet.Tests.ps1:21
   at <ScriptBlock>, C:\t\Planets\Get-Planet.Tests.ps1:21
Tests completed in 195ms
```

The error is: `Expected 1, but got 8.`, this again reflects exactly what we did in the test, but it no longer reflects the real world. 

### How tests break

If you look closer on how we broke the test, you can see that there are two distinct ways to break it. 
- The first was that the tested function did not work correctly, this is a good way to break the test. 
- The second one is when the function works correctly, but the test is incorrect. This it a bad way to break the test. 

Being able to distinguish between those two is important, when your test breaks keep in mind that either the function, or the tests might be broken. What you usually do is that you look at what changed more recently. If the test is new, and the function existed for a while, you first blame the test. When the test was passing before, but it is not anymore, you first blame the tested function.


## Other keywords

Now that we know about It, and Should. We can quickly look at the rest of the Pester keywords that we used. 

### Describe 

This keyword allows you to group tests (represented by `It` blocks) into groups. You can have one or more `Describe`s per file. You can also nest `Describe`s into each other to give your test suite more structure. 

A similar keyword to `Describe` is `Context`. In almost all cases `Context` can be used interchangeably with `Describe`. Typically the top-level block is a `Describe` that is named after the function that is being tested. And then, if needed, `Context` blocks are used inside of the `Describe` to group tests based on what aspect of the function you are testing. 

Like this: 

```powershell
Describe 'Get-Planet' {
    Context 'no parameters' {
        It 'lists all 8 planets' {
            # ..
        }

        It 'lists them in the correct order' { 
            # ...
        }
    }

    Context "with -Filter" { 
        It 'filters based on planet Name' {
            # ...
        }
    }
}
```
### BeforeAll

Now that we split the tests into groups we might want to share some common code among those tests. This code can be run before the test, to set the tests up. Or it can run after the tests, to clean up after them. To do this we have few special blocks. One of them is `BeforeAll`, which runs code at the start of the given `Describe`. In our example we used it to define the tested function. `BeforeAll` will run once, before the block it is placed in

There is also `BeforeEach




Now let's make the test fail. One way to do that is to set a false assumption, for example that there is just 1 planet in our Solar system. W  (Or more precisely, I want 8 items )   let's break it. Change the `$allPlanets.Count | Should -Be 8` to `$allPlanets.Count | Should -Be 7`. Like this: 

 ```powershell
 It 'Given no parameters, it lists all 8 planets' {
    $allPlanets = Get-Planet
    $allPlanets.Count | Should -Be 8
}
```

Spend some time inspecting the code of our first test. Some of it should be familiar, and some of it will look a 
bit foreign. 

`Describe`, `BeforeAll`, `It` and `Should` are Pester keywords. They each have a different function, and we will 
go over all of them shortly. 

But now we are most interested in `It` and `Should`. `It` represents a single test,
 such test can either pass or fail. 




both a new implementation function and a test function. New-Fixture assumes that you will be testing
the contents of a `.ps1` file (not a `.psm1` file, or Script Module), that the test script should be
in the same directory as the script under test, and that the name of the test script should be
`<Name of Script Under Test>.Tests.ps1`.

To scaffold a new project, use the script below to generate a placeholder function script and test script.

```powershell
New-Fixture deploy Clean

<#
Creates two files:
./deploy/Clean.ps1
#>

function Clean {

}

# ./deploy/Clean.Tests.ps1

$here = Split-Path -Parent $MyInvocation.MyCommand.Path
$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
. "$here\$sut"

Describe "Clean" {
    It "does something useful" {
        $true | Should Be $false
    }
}
```

With this skeleton of a function called "Clean" and a failing test, Test-Driven Development activities can start.

Pester test script filenames _must_ end with `.Tests.ps1` suffix in order for [Invoke-Pester](./commands/Invoke-Pester)
to discover and run them. (eg. MyScript.Tests.ps1).

Test scripts named with or without this suffix can be run manually using -Script parameter.

```powershell
Invoke-Pester -Script .\Test-ScriptWithPesterTest.ps1
```

In addition to filename discovery of the `\*.Tests.ps1` pattern by the [Invoke-Pester](./commands/Invoke-Pester)
command, Pester discovers `Describe` blocks (logical groupings of tests) within the test file
(see [Describe](./commands/Describe)).

The `Describe` block can contain several behavior validations expressed in [It](./commands/It) blocks (see [It](./commands/It)).
Each [It](./commands/It) block should test one thing and throw an exception if the test fails. Pester will consider any
 [It](./commands/It) block that throws an exception to be a failed test.

Pester provides a command called [Should](./commands/Should) that can perform various comparisons between the values emitted
or altered by a command and an expected value (see [Should](./commands/Should)).

## Running a Pester test

Use the [Invoke-Pester](./commands/Invoke-Pester) command to run tests (see [Invoke-Pester](./commands/Invoke-Pester)). [Invoke-Pester](./commands/Invoke-Pester) can be run against all the
`\*.Tests.ps1` files in an entire tree of directories or it can zero in on just one test group (`Describe` block)
using `-TestName` parameter. The `-Tag` parameter in the [Describe](./commands/Describe) block can also be used for targeted testing,
categorization and filtering of tests.

As of Pester version 3.0, direct execution of any `.Tests.ps1` script file is available without using
[Invoke-Pester](./commands/Invoke-Pester) test harness; with test output written to the console. By running tests directly, many
of the benefits of the test framework are unavailable.

Benefits to running from [Invoke-Pester](./commands/Invoke-Pester) test framework include the following:

- Produce NUnit XML files or other output objects
- Code Coverage analysis.
- Exit codes from PowerShell.exe
- Filtering of tests to execute
- Status summary of tests executed / failed when test run is complete.

## Pester and Continuous Integration (CI)

Pester integrates with almost any build automation solution. See [Showing Test Results in CI (TeamCity, AppVeyor, Azure DevOps)](./usage/test-results)

An example of a PowerShell script to run against a single pester test file using an Azure Devops Inline Powershell script task.

```powershell
# This updates pester not always necessary but worth noting
Install-Module -Name Pester -Force -SkipPublisherCheck

Import-Module Pester

Invoke-Pester -Script $(System.DefaultWorkingDirectory)\MyFirstModule.test.ps1 -OutputFile $(System.DefaultWorkingDirectory)\Test-Pester.XML -OutputFormat NUnitXML
```

An example of an MSBuild target that calls Pester's convenience helper Batch file to run a suite of tests:

```xml
<Target Name="Tests">
    <Exec Command="cmd /c $(baseDir)pester\bin\pester.bat" />
</Target>
```

The MSBuild example will start a PowerShell session, import the Pester Module and call [Invoke-Pester](./commands/Invoke-Pester)
within the current directory. If any test fails, it will return an exit code equal to the number of failed
tests and all test results will be saved to Test.xml using NUnit's Schema. This file can be published as
test results as part of the build into most build systems like Azure Devops, CruiseControl, TeamCity, TFS
or Jenkins. See [Showing Test Results in CI (TeamCity, AppVeyor, Azure DevOps)](./usage/test-results)

## Other Examples

- Pester's own Test [Examples](https://github.com/pester/Pester/tree/master/Examples). See all files in the Pester Functions folder containing `.Tests.ps1`
- Chocolatey tests. Chocolatey is a popular PowerShell-based Windows package management system. It uses Pester tests to validate its own functionality.
