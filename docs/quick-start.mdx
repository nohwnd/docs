---
id: quick-start
title: Quick Start
sidebar_label: Quick Start
---

## What is Pester?

Pester is a testing and mocking framework for PowerShell.

Pester provides a framework for writing and running tests. Pester is most commonly 
used for writing unit and integration tests, but it is not limited to just that. 
It is also a base for tools that validate whole environments, computer deployments, database configurations and so on. 

Pester follows a file naming convention `*.Tests.ps1`, and uses a simple set of functions: 
`Describe`, `Context`, `It`, `Should` and `Mock` to create a mini-DSL for writing your tests.

Pester tests can execute any command or script that is accessible to a Pester test file. This
includes functions, Cmdlets, Modules and scripts. Pester can be run locally, where it integrates well 
with Visual Studio Code, and it can of course be integrated into a build script in a CI pipeline.

Pester contains a powerful set of Mocking capabilities that allow tests to replace the behavior of any 
command inside of a piece of PowerShell code being tested. See [Mocking with Pester](./usage/mocking).

Pester can produce artifacts such as Test Results file and can be used for generating
[Code Coverage](./usage/code-coverage) and [Test Result](./usage/test-results) files for reporting 
results in CI pipeline.

## Installing Pester

To install Pester it is usually enough to just do `Install-Module Pester -Force` followed by 
`Import-Module Pester -PassThru`. This is the output you should see in the console: 

```shell
C:\> Import-Module Pester -Passthru

ModuleType Version    PreRelease Name
---------- -------    ---------- ----
Script     5.0.4                 Pester
```

Full installation guide is available in [installation](installation).

## Creating a Pester Test

To start using Pester, create a new file called `Get-Planet.Tests.ps1`. `Get-Planet` is the name of the function
we will be testing. Feel free to replace that with your own function name. The file name is important because Pester 
uses a naming convention, all `*.Tests.ps1` files will be inspected for tests.

Inside of the file paste this code:

```powershell
Describe 'Get-Planet' {
    BeforeAll { 
        function Get-Planet ([string]$Name = '*') {
            $planets = @(
                @{ Name = 'Mercury' }
                @{ Name = 'Venus'   }
                @{ Name = 'Earth'   }
                @{ Name = 'Mars'    }
                @{ Name = 'Jupiter' }
                @{ Name = 'Saturn'  }
                @{ Name = 'Uranus'  }
                @{ Name = 'Neptune' }
            ) | ForEach-Object { [PSCustomObject] $_ }

            $planets | Where-Object { $_.Name -like $Name }
        }
    }

    It 'Given no parameters, it lists all 8 planets' {
        $allPlanets = Get-Planet
        $allPlanets.Count | Should -Be 8
    }
}
```

This code uses multiple Pester keywords, and we will go over them in detail soon, but for now let's just run it.

In your console run `Invoke-Pester -Output Detailed C:\t\Planets\Get-Planet.Tests.ps1`:

```shell
Starting discovery in 1 files.
Discovering in C:\t\Planets\Get-Planet.Tests.ps1.
Found 1 tests. 41ms
Discovery finished in 77ms.

Running tests from 'C:\t\Planets\Get-Planet.Tests.ps1'
Describing Get-Planet
  [+] Given no parameters, it lists all 8 planets 20ms (18ms|2ms)
Tests completed in 179ms
Tests Passed: 1, Failed: 0, Skipped: 0 NotRun: 0
```

Looking at the last line of output you can see that we run 1 test and it Passed. Good job, you just run your first Pester test! ðŸ¥³ðŸ¥³ðŸ¥³

### Understanding our test

In the previous run, our test passed, and if you'd run it again it would pass again. That is the beauty of automated testing. This is because using the `Should` keyword we are saying:

> ðŸ‘‰ "There should be 8 items in `$allPlanets`."

And there are. 

But how did we know that we want to test for exactly that? Well, we didn't. It was just one example of how we could describe our Solar System. You can try remembering some facts about it and try writing them as tests.

Here are few examples: 

- Earth is the third planet in our Solar System. 
- Pluto is not part of our Solar System.
- The planets go in this order: Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune.
  

```powershell
It 'Earth is the third planet in our Solar System' {
    $allPlanets = Get-Planet
    $allPlanets[2].Name | Should -Be 'Earth'
}
```

```powershell
It 'Pluto is not part of our Solar System' {
    $allPlanets = Get-Planet
    $plutos = $allPlanets | Where-Object Name -EQ 'Pluto'
    $plutos.Count | Should -Be 0
}
```

```powershell
It 'Planets have this order: Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune' {
    $allPlanets = Get-Planet
    $planetsInOrder = $allPlanets.Name -join ', ' 
    $planetsInOrder | Should -Be "Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune"
} 
```

# <<<< continue writing here >>>>

### Breaking our test

In the previous run, our test passed, and if you run it again it will pass again. That is the beauty of automated testing. This is because using the `Should` keyword we are saying:

> There should be 8 items in `$allPlanets`.

 And there are. 

 There would be multiple other ways to 
 
 Now let's make the test fail. One way to do that is to set a false assumption, for example that there is just 1 planet in our Solar system. W  (Or more precisely, I want 8 items )   let's break it. Change the `$allPlanets.Count | Should -Be 8` to `$allPlanets.Count | Should -Be 7`. Like this: 

 ```powershell
 It 'Given no parameters, it lists all 8 planets' {
    $allPlanets = Get-Planet
    $allPlanets.Count | Should -Be 8
}
```

Spend some time inspecting the code of our first test. Some of it should be familiar, and some of it will look a 
bit foreign. 

`Describe`, `BeforeAll`, `It` and `Should` are Pester keywords. They each have a different function, and we will 
go over all of them shortly. 

But now we are most interested in `It` and `Should`. `It` represents a single test,
 such test can either pass or fail. 




both a new implementation function and a test function. New-Fixture assumes that you will be testing
the contents of a `.ps1` file (not a `.psm1` file, or Script Module), that the test script should be
in the same directory as the script under test, and that the name of the test script should be
`<Name of Script Under Test>.Tests.ps1`.

To scaffold a new project, use the script below to generate a placeholder function script and test script.

```powershell
New-Fixture deploy Clean

<#
Creates two files:
./deploy/Clean.ps1
#>

function Clean {

}

# ./deploy/Clean.Tests.ps1

$here = Split-Path -Parent $MyInvocation.MyCommand.Path
$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
. "$here\$sut"

Describe "Clean" {
    It "does something useful" {
        $true | Should Be $false
    }
}
```

With this skeleton of a function called "Clean" and a failing test, Test-Driven Development activities can start.

Pester test script filenames _must_ end with `.Tests.ps1` suffix in order for [Invoke-Pester](./commands/Invoke-Pester)
to discover and run them. (eg. MyScript.Tests.ps1).

Test scripts named with or without this suffix can be run manually using -Script parameter.

```powershell
Invoke-Pester -Script .\Test-ScriptWithPesterTest.ps1
```

In addition to filename discovery of the `\*.Tests.ps1` pattern by the [Invoke-Pester](./commands/Invoke-Pester)
command, Pester discovers `Describe` blocks (logical groupings of tests) within the test file
(see [Describe](./commands/Describe)).

The `Describe` block can contain several behavior validations expressed in [It](./commands/It) blocks (see [It](./commands/It)).
Each [It](./commands/It) block should test one thing and throw an exception if the test fails. Pester will consider any
 [It](./commands/It) block that throws an exception to be a failed test.

Pester provides a command called [Should](./commands/Should) that can perform various comparisons between the values emitted
or altered by a command and an expected value (see [Should](./commands/Should)).

## Running a Pester test

Use the [Invoke-Pester](./commands/Invoke-Pester) command to run tests (see [Invoke-Pester](./commands/Invoke-Pester)). [Invoke-Pester](./commands/Invoke-Pester) can be run against all the
`\*.Tests.ps1` files in an entire tree of directories or it can zero in on just one test group (`Describe` block)
using `-TestName` parameter. The `-Tag` parameter in the [Describe](./commands/Describe) block can also be used for targeted testing,
categorization and filtering of tests.

As of Pester version 3.0, direct execution of any `.Tests.ps1` script file is available without using
[Invoke-Pester](./commands/Invoke-Pester) test harness; with test output written to the console. By running tests directly, many
of the benefits of the test framework are unavailable.

Benefits to running from [Invoke-Pester](./commands/Invoke-Pester) test framework include the following:

- Produce NUnit XML files or other output objects
- Code Coverage analysis.
- Exit codes from PowerShell.exe
- Filtering of tests to execute
- Status summary of tests executed / failed when test run is complete.

## Pester and Continuous Integration (CI)

Pester integrates with almost any build automation solution. See [Showing Test Results in CI (TeamCity, AppVeyor, Azure DevOps)](./usage/test-results)

An example of a PowerShell script to run against a single pester test file using an Azure Devops Inline Powershell script task.

```powershell
# This updates pester not always necessary but worth noting
Install-Module -Name Pester -Force -SkipPublisherCheck

Import-Module Pester

Invoke-Pester -Script $(System.DefaultWorkingDirectory)\MyFirstModule.test.ps1 -OutputFile $(System.DefaultWorkingDirectory)\Test-Pester.XML -OutputFormat NUnitXML
```

An example of an MSBuild target that calls Pester's convenience helper Batch file to run a suite of tests:

```xml
<Target Name="Tests">
    <Exec Command="cmd /c $(baseDir)pester\bin\pester.bat" />
</Target>
```

The MSBuild example will start a PowerShell session, import the Pester Module and call [Invoke-Pester](./commands/Invoke-Pester)
within the current directory. If any test fails, it will return an exit code equal to the number of failed
tests and all test results will be saved to Test.xml using NUnit's Schema. This file can be published as
test results as part of the build into most build systems like Azure Devops, CruiseControl, TeamCity, TFS
or Jenkins. See [Showing Test Results in CI (TeamCity, AppVeyor, Azure DevOps)](./usage/test-results)

## Other Examples

- Pester's own Test [Examples](https://github.com/pester/Pester/tree/master/Examples). See all files in the Pester Functions folder containing `.Tests.ps1`
- Chocolatey tests. Chocolatey is a popular PowerShell-based Windows package management system. It uses Pester tests to validate its own functionality.
